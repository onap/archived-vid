/*-
 * ============LICENSE_START=======================================================
 * VID
 * ================================================================================
 * Copyright (C) 2017 AT&T Intellectual Property. All rights reserved.
 * ================================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============LICENSE_END=========================================================
 */

"use strict";

/*
 * "UtilityService" contains various generic methods.
 * 
 * (*** DEPRECATED - Use PropertyService instead ***) setProperties() and
 * getProperties()
 * 
 * SYNTAX: hasContents(object)
 * 
 * Returns "true" if "object" contains contents (i.e. is NOT undefined, null or
 * ""), "false" otherwise.
 * 
 * SYNTAX: checkUndefined(name, value)
 * 
 * Throws an exception if "value" is undefined. The exception includes "name" as
 * the cause of the exception. Returns "value" if it is defined.
 * 
 * SYNTAX: getCurrentTime()
 * 
 * Returns the current local date and time in the format "MM/DD/YY HH:MM:SS"
 * 
 * SYNTAX: setHttpErrorHandler(function)
 * 
 * Sets the HTTP error handler to "function".
 * 
 * SYNTAX: runHttpErrorHandler(response, status)
 * 
 * Logs warning messages and the runs the HTTP error handler previously set by
 * "setHttpErrorHandler". The intended usage is for "$http" calls. Example:
 * $http.get(...).then(...)["catch"](UtilityService.runHttpErrorHandler);
 * 
 * SYNTAX: getHttpStatusText(statusCode)
 * 
 * Expects "statusCode" to be an HTTP response code (e.g. 404). The function
 * returns a string that includes both the code and an equivalent text summary.
 * Example: "Not found (404)"
 * 
 * SYNTAX: getHttpErrorMessage(response)
 * 
 * Expects "response" to be the response object generated by a "$http" error
 * condition. "getHttpErrorMessage" examines the object and returns a summary
 * string for some known conditions.
 */

var UtilityService = function($log) {

    var _this = this;

    function hasContents(object) {
	if (object === undefined || object === null || object === "") {
	    return false;
	}
	return true;
    }

    function padZero(number) {
	if (number < 10) {
	    return "0" + number;
	} else {
	    return "" + number;
	}
    }

    var httpErrorHandler = function(response, status) {
	$log.warn("UtilityService:httpErrorHandler: response:");
	$log.warn(response);
	$log.warn("UtilityService:httpErrorHandler: status:");
	$log.warn(status);
	if (angular.isFunction(_this.httpErrorHandler)) {
	    _this.httpErrorHandler(response, status);
	}
    };

    var startNextAsyncOperation = function() {
	if (_this.asyncOperations.count < _this.asyncOperations.operationList.length) {
	    _this.asyncOperations.operationList[_this.asyncOperations.count++]
		    ();
	} else {
	    if (angular.isFunction(_this.asyncOperations.callbackFunction)) {
		_this.asyncOperations.callbackFunction();
	    }
	}
    };

    return {
	setProperties : function(properties) {
	    _this.properties = properties;
	},
	getProperties : function() {
	    return _this.properties;
	},
	hasContents : hasContents,
	checkUndefined : function(name, value) {
	    if (value === undefined) {
		throw {
		    type : "undefinedObject",
		    message : "undefined object: \"" + name + "\""
		};
	    }
	    return value;
	},
	getCurrentTime : function() {
	    var time = new Date();
	    return padZero(time.getMonth() + 1) + "/"
		    + padZero(time.getDate() + 1) + "/"
		    + (time.getFullYear() - 2000) + " "
		    + padZero(time.getHours()) + ":"
		    + padZero(time.getMinutes()) + ":"
		    + padZero(time.getSeconds())
	},
	getHttpStatusText : function(statusCode) {
	    var statusMap = {
		"200" : "OK",
		"201" : "Created",
		"202" : "Accepted",
		"400" : "Bad Request",
		"401" : "Unauthorized",
		"404" : "Not Found",
		"405" : "Method Not Allowed",
		"409" : "Locked",
		"500" : "Internal Server Error",
		"503" : "Service Unavailable",
		"504" : "Gateway Timeout"
	    }

	    if (status === undefined) {
		return "Undefined";
	    }

	    var statusText = statusMap[statusCode];
	    if (statusText === undefined) {
		statusText = "Unknown";
	    }

	    return statusText + " (" + statusCode + ")";
	},
	getHttpErrorMessage : function(response) {
	    var data = response.data;
	    if (response.status === 500 && hasContents(data.exception)) {
		var summary = "exception: " + data.exception;
		if (hasContents(data.message)) {
		    summary += " message: " + data.message;
		}
		return summary;
	    }
	    if (response.status === 0 && response.statusText === "") {
		/*
		 * This logic is somewhat "fuzzy". Potential (brainstorming)
		 * enhancements if users find the message unreliable include:
		 * 
		 * A) SERVER TIMEOUT: perhaps a newer version of Angular can
		 * reliably determine timeouts.
		 * 
		 * B) SERVER TIMEOUT: recording start / end times and using that
		 * to determine if timeout occured
		 * 
		 * C) SESSION TIMEOUT "Potentially" examine cookies, although
		 * that may not be feasible if cookies are set to "httponly".
		 */
		if (data === null) {
		    return "possible server timeout";
		}
		if (data === "") {
		    return "Possible reasons include a session timeout or a server issue. "
			    + "A session timeout might be resolved by refreshing the screen and re-logging in";
		}
	    }
	    var summary = "";
	    if (response.status !== undefined && response.status > 0) {
		summary = "status: " + response.status;
	    }
	    if (hasContents(response.statusText)) {
		if (summary !== "") {
		    summary += " ";
		}
		summary += "message: " + response.statusText;
	    }
	    return summary;
	},
	setHttpErrorHandler : function(httpErrorHandler) {
	    _this.httpErrorHandler = httpErrorHandler;
	},
	runHttpErrorHandler : function(response, status) {
	    httpErrorHandler(response, status);
	},
	startAsyncOperations : function(operationList, callbackFunction) {
	    for (var i = 0; i < operationList.length; i++) {
		if (!angular.isFunction(operationList[i])) {
		    throw "UtilityService:startAsyncOperations: invalid function: index: "
			    + i;
		}
	    }
	    _this.asyncOperations = {
		operationList : operationList,
		callbackFunction : callbackFunction,
		count : 0
	    };
	    startNextAsyncOperation();
	},
	startNextAsyncOperation : startNextAsyncOperation,
	stopAsyncOperations : function() {
	    _this.asyncOperations.count = _this.asyncOperations.operationList.length;
	}
    }
}

app.factory("UtilityService", UtilityService);
